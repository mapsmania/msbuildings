<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>MapLibre + Quadkey Building Footprints (GitHub Pages)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body, #map { height: 100%; margin:0; padding:0; }
    #info {
      position: absolute; top: 8px; left: 8px; z-index: 2;
      background: rgba(255,255,255,0.9); padding: 8px;
      border-radius: 6px; box-shadow: 0 1px 4px rgba(0,0,0,0.2);
      max-width: 320px; font-family: sans-serif;
    }
    button { margin-top:6px; }
  </style>
  <!-- MapLibre GL JS -->
  <link href="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js"></script>
</head>
<body>
<div id="map"></div>
<div id="info">
  <strong>GitHub Pages: Quadkey Footprints Demo</strong><br>
  Zoom target: <span id="tileZoom">14</span><br>
  Pan/zoom to load tiles. <br>
  <button id="clear">Clear layers</button>
</div>

<script>
/* -----------------------
   Configuration
----------------------- */
const TILE_ZOOM = 14; // zoom level of tiles
const MAX_TILES = 48; // safety limit

/* -----------------------
   Helpers: tile <-> quadkey
----------------------- */
function tileXYToQuadKey(x, y, z){
  let qk = '';
  for(let i=z;i>0;i--){
    let digit=0;
    const mask=1<<(i-1);
    if(x&mask) digit+=1;
    if(y&mask) digit+=2;
    qk+=digit.toString();
  }
  return qk;
}
function lonLatToTileXY(lon, lat, z){
  const latRad = lat*Math.PI/180;
  const n = 2**z;
  const x = Math.floor((lon+180)/360*n);
  const y = Math.floor((1 - (Math.log(Math.tan(latRad) + 1/Math.cos(latRad))/Math.PI))/2*n);
  return [x,y];
}

/* -----------------------
   Service Worker (blob)
----------------------- */
if('serviceWorker' in navigator){
  const swCode = `
    const INDEX_URL = 'https://minedbuildings.z5.web.core.windows.net/global-buildings/dataset-links.csv';
    let quadIndex = null;

    self.addEventListener('install', evt => evt.waitUntil(self.skipWaiting()));
    self.addEventListener('activate', evt => evt.waitUntil(self.clients.claim()));

    async function loadIndex(){
      if(quadIndex) return quadIndex;
      quadIndex = new Map();
      try{
        const r = await fetch(INDEX_URL);
        const csv = await r.text();
        const lines = csv.split('\\n').map(s=>s.trim()).filter(Boolean);
        if(lines.length<2) return quadIndex;
        const header=lines[0].split(',');
        const idxQuad=header.findIndex(h=>h.toLowerCase().includes('quad'));
        const idxUrl=header.findIndex(h=>h.toLowerCase().includes('url'));
        if(idxQuad===-1 || idxUrl===-1) return quadIndex;
        for(let i=1;i<lines.length;i++){
          const row=lines[i].split(',');
          const q=row[idxQuad]; const u=row[idxUrl];
          if(q && u) quadIndex.set(q.trim(), u.trim());
        }
      }catch(e){ console.warn('SW load index error',e); }
      return quadIndex;
    }

    function tileXYToQuadKey(x,y,z){
      let qk=''; for(let i=z;i>0;i--){
        let d=0; const m=1<<(i-1);
        if(x&m)d+=1; if(y&m)d+=2; qk+=d.toString();
      } return qk;
    }

    function ndjsonToFeatureCollection(txt){
      const features=[]; txt.split('\\n').forEach(l=>{
        const ln=l.trim(); if(!ln) return;
        try{
          const obj=JSON.parse(ln);
          if(obj.type==='Feature'&&obj.geometry) features.push(obj);
          else if(obj.geometry){
            const props=Object.assign({},obj); delete props.geometry;
            features.push({type:'Feature',geometry:obj.geometry,properties:props});
          }
        }catch(e){}
      }); return {type:'FeatureCollection',features};
    }

    self.addEventListener('fetch', evt=>{
      const url=new URL(evt.request.url);
      const m=url.pathname.match(/quad\/(\\d+)\\/(\\d+)\\/(\\d+)\\.geojson$/);
      if(!m) return;
      evt.respondWith((async()=>{
        try{
          await loadIndex();
          const z=parseInt(m[1]), x=parseInt(m[2]), y=parseInt(m[3]);
          const qk=tileXYToQuadKey(x,y,z);
          const tileUrl=quadIndex.get(qk);
          if(!tileUrl) return new Response(JSON.stringify({type:'FeatureCollection',features:[]}),
            {headers:{'Content-Type':'application/json'}});
          const r=await fetch(tileUrl);
          if(!r.ok) return new Response(JSON.stringify({type:'FeatureCollection',features:[]}),
            {headers:{'Content-Type':'application/json'}});
          const txt=await r.text();
          return new Response(JSON.stringify(ndjsonToFeatureCollection(txt)),
            {headers:{'Content-Type':'application/json'}});
        }catch(e){
          return new Response(JSON.stringify({type:'FeatureCollection',features:[]}),
            {headers:{'Content-Type':'application/json'},status:500});
        }
      })());
    });
  `;
  const blob = new Blob([swCode],{type:'text/javascript'});
  navigator.serviceWorker.register(URL.createObjectURL(blob))
    .then(()=>console.log('SW registered')).catch(e=>console.warn(e));
}

/* -----------------------
   MapLibre Map
----------------------- */
const map = new maplibregl.Map({
  container:'map',
  style:{
    version:8,
    sources:{
      'osm':{
        type:'raster',
        tiles:['https://a.tile.openstreetmap.org/{z}/{x}/{y}.png'],
        tileSize:256,
        attribution:'Â© OpenStreetMap contributors'
      }
    },
    layers:[{id:'osm',type:'raster',source:'osm'}]
  },
  center:[23.7275,37.9838],
  zoom:12
});
map.addControl(new maplibregl.NavigationControl(),'top-right');
document.getElementById('tileZoom').textContent=TILE_ZOOM;

const addedSources = new Set();
function clearLayers(){
  addedSources.forEach(id=>{
    if(map.getLayer(id+'-fill')) map.removeLayer(id+'-fill');
    if(map.getLayer(id+'-outline')) map.removeLayer(id+'-outline');
    if(map.getSource(id)) map.removeSource(id);
  });
  addedSources.clear();
}
document.getElementById('clear').addEventListener('click',clearLayers);

function visibleTiles(z){
  const b=map.getBounds();
  const [xMin,yMin]=lonLatToTileXY(b.getNorthWest().lng,b.getNorthWest().lat,z);
  const [xMax,yMax]=lonLatToTileXY(b.getSouthEast().lng,b.getSouthEast().lat,z);
  const xmin=Math.min(xMin,xMax), xmax=Math.max(xMin,xMax);
  const ymin=Math.min(yMin,yMax), ymax=Math.max(yMin,yMax);
  const tiles=[];
  for(let x=xmin;x<=xmax;x++)
    for(let y=ymin;y<=ymax;y++) tiles.push({x,y,z});
  return tiles;
}

async function loadTiles(){
  const tiles=visibleTiles(TILE_ZOOM);
  if(tiles.length>MAX_TILES){ console.warn('Too many tiles'); return; }
  for(const t of tiles){
    const qk=tileXYToQuadKey(t.x,t.y,t.z);
    const id='qk-'+qk;
    if(addedSources.has(id)) continue;
    const url=`./quad/${t.z}/${t.x}/${t.y}.geojson`;
    try{
      const r=await fetch(url); if(!r.ok) continue;
      const geojson=await r.json();
      if(!geojson.features||geojson.features.length===0) continue;
      map.addSource(id,{type:'geojson',data:geojson});
      map.addLayer({id:id+'-fill',type:'fill',source:id,paint:{'fill-color':'#ff7f0e','fill-opacity':0.4}});
      map.addLayer({id:id+'-outline',type:'line',source:id,paint:{'line-color':'#b03a2e','line-width':1}});
      addedSources.add(id);
    }catch(e){console.warn(e); }
  }
}
let timer=null;
function scheduleLoad(){ if(timer) clearTimeout(timer); timer=setTimeout(()=>{loadTiles(); timer=null;},300);}
map.on('load',()=>scheduleLoad());
map.on('moveend',()=>scheduleLoad());
</script>
</body>
</html>
